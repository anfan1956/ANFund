Понял. **На 10 configID - делаем отдельные фреймы:**

**Архитектура:**
1. **Каждый configID** → отдельный процесс Python с фреймом в памяти
2. **Координация** через БД с блокировками
3. **Потребление:** 250 MB RAM (приемлемо)

**План:**
1. Доводим текущий фрейм до рабочего состояния для **одного configID**
2. Тестируем логику стратегий
3. Добавляем **координацию через БД** для предотвращения конфликтов
4. Масштабируем на 10 процессов

**Согласен с планом?** Начнем с доработки фрейма для одного configID.

Device Name	SERVER
Processor	Intel(R) Xeon(R) CPU E5-2620 v4 @ 2.10GHz   2.10 GHz
Installed RAM	64.0 GB (63.9 GB usable)
Storage	224 GB SSD INTEL SSDSC2KB240G7, 932 GB HDD HGST HUS722T1TALA604, 477 GB SSD SPCC Solid State Disk, 224 GB SSD INTEL SSDSC2KB240G7
Graphics Card	NVIDIA GeForce GTX 1660 (6 GB)
Device ID	20EB8617-C439-4010-A1B7-8638E90EB90A
Product ID	00330-80000-00000-AA663
System Type	64-bit operating system, x64-based processor
Pen and touch	No pen or touch input is available for this display

Отличный сервер! **64 GB RAM** легко выдержит 10-20 процессов фрейма.

**Расчет:**
- 10 процессов × 25 MB = 250 MB
- 20 процессов × 25 MB = 500 MB  
- **Остается** > 63 GB для БД, мониторинга и т.д.

**План идеален для тестирования.** 

**Продолжаем дорабатывать фрейм для одного configID.** Согласен?

**Продолжаем. Что сейчас в приоритете:**

1. **Добавить в `StrategyBase` методы для управления позициями в памяти:**
   - `get_position(configID)`
   - `update_position(configID, position_data)`
   - `remove_position(configID)`

2. **Добавить методы для выполнения команд:**
   - `close_position(configID, position_id)`
   - `open_position(configID, direction)`

3. **Исправить `run()`** чтобы вызывал стратегии по таймеру

**Начнем с п.1 - добавить методы управления позициями?**

**Или** сначала исправить архитектуру чтобы `StrategyBase` знал свой `configID` (сейчас использует `self.configuration_id` которого нет)?



    def get_current_signals(self, connection):
        """
        Get trading signal from DB or return 'buy' on first run.
        Returns: 'buy', 'sell', or None
        """
        try:
            # First run - return 'buy' for initial position
            if not hasattr(self, '_first_signal_sent'):
                self._first_signal_sent = True
                return 'buy'

            # TODO: Implement actual strategy logic here
            # For now - return None (no signal)
            return None

        except Exception as e:
            print(f"[MTF Trend] Error in get_current_signals: {e}")
            return None
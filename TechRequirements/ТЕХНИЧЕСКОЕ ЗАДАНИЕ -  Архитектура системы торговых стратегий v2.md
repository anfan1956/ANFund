# ТЕХНИЧЕСКОЕ ЗАДАНИЕ: АРХИТЕКТУРА СИСТЕМЫ ТОРГОВЫХ СТРАТЕГИЙ

## 1. ТЕКУЩАЯ АРХИТЕКТУРА

### 1.1. Структура данных (упрощенная)
```
algo.strategies (ID, strategy_code, strategy_name, strategy_class_id)
    ↓ FK strategy_class_id
algo.strategy_classes (ID, class_name, class_code)
    ↓ FK strategy_id
algo.ParameterSets (Id, strategy_id, ParameterSetJson)
    ↓ FK parameter_set_id
algo.ConfigurationSets (Id, ParameterSetId, ParameterValuesJson, CreatedAt)
```

### 1.2. Конфигурация стратегии
- **Идентификатор**: `ConfigurationSets.Id`
- **Параметры**: JSON в `ParameterValuesJson`
- **Пример для MTF RSI EMA:**
```json
{
    "ticker": "XAUUSD",
    "ticker_jid": 123,
    "timeframe_signal_id": 1,
    "timeframe_confirmation_id": 3,
    "timeframe_trend_id": 5,
    "open_volume": 0.01,
    "trading_close_utc": "22:00",
    "trading_start_utc": "00:00",
    "broker_id": 2,
    "platform_id": 1,
    "max_position_checks": 10,
    "check_interval_seconds": 10
}
```

## 2. ТРЕБОВАНИЯ К PYTHON-СТРАТЕГИЯМ

### 2.1. Обязательная структура класса
```python
class StrategyBase:
    def __init__(self, configuration_id: int):
        self.configuration_id = configuration_id
        self.connection_string = "DRIVER={...}"
        self.config = self._load_configuration()
        self.termination_service = StrategyTerminationService(self.connection_string)
    
    def run(self):
        """Основной цикл стратегии"""
    
    def _update_tracker_state(self, state: str):
        """Обновление статуса в algo.strategyTracker"""
```

### 2.2. Интерфейс запуска
```bash
python <strategy_name>.py --config-id <ConfigurationSets.Id>
```

### 2.3. Обязательные функции
1. **Загрузка конфигурации** из `algo.ConfigurationSets`
2. **Проверка завершения** через `StrategyTerminationService`
3. **Heartbeat** каждые 60 секунд в `algo.strategyTracker`
4. **Логирование** торговых событий в `algo.tradeLog`

## 3. ЖИЗНЕННЫЙ ЦИКЛ СТРАТЕГИИ

### 3.1. Старт
1. Загрузка конфигурации по `configuration_id`
2. Отправка статуса `'start'` в `algo.strategyTracker`
3. Инициализация торговых параметров

### 3.2. Рабочий цикл (каждые 60 секунд)
1. Быстрая проверка терминации (каждые 100мс)
2. Основная торговая логика
3. Отправка heartbeat при необходимости
4. Проверка торговых часов

### 3.3. Завершение
1. По команде из `algo.strategy_termination_queue`
2. Закрытие всех позиций через `trd.sp_CreateSignal`
3. Отправка статуса `'stop'` или `'terminated'`
4. Выход из программы

## 4. ОБЯЗАТЕЛЬНЫЕ КОМПОНЕНТЫ

### 4.1. StrategyTerminationService
- Синглтон с кешированием (TTL 5 секунд)
- Быстрая проверка команд завершения
- Методы: `check_my_termination()`, `mark_completed()`

### 4.2. sp_create_signal.py
- Функция `execute_signal_procedure()`
- Отправка торговых сигналов через `trd.sp_CreateSignal`
- Поддержка направлений: `'buy'`, `'sell'`, `'drop'`

### 4.3. Работа с данными
- Цены: `tms.bars` (timeframeID = 1 для M1)
- Индикаторы: `tms.EMA`, `tms.Indicators_Momentum`
- Позиции: `trd.trades_v` (tradeType = 'POSITION')

## 5. SQL-ИНТЕРФЕЙСЫ

### 5.1. Функции для стратегий
```sql
-- Получение конфигурации
algo.fn_GetStrategyConfiguration(@config_id)

-- Получение торговых сигналов
algo.fn_GetCurrentSignals(@ticker_jid, @tf1, @tf2, @tf3)

-- Обновление статуса стратегии
algo.sp_UpdateStrategyState(@configID, @currentState)
```

### 5.2. Ключевые представления
- `trd.trades_v` - открытые позиции и ордера
- `tms.vw_bars_with_signals` - бары с индикаторами
- `tms.vw_Momentum_Signals` - сигналы моментума

## 6. МОНИТОРИНГ И УПРАВЛЕНИЕ

### 6.1. Таблицы мониторинга
- `algo.strategyTracker` - статусы работающих стратегий
- `algo.strategy_termination_queue` - команды завершения
- `algo.tradeLog` - лог торговых событий

### 6.2. Управление
```sql
-- Добавление команды завершения
INSERT INTO algo.strategy_termination_queue 
(config_id, terminate) VALUES (@config_id, 1)

-- Просмотр работающих стратегий
SELECT * FROM algo.strategiesDashboard_v
```

## 7. ТРЕБОВАНИЯ К НОВЫМ СТРАТЕГИЯМ

### 7.1. Минимальный набор методов
1. `__init__(configuration_id)` - инициализация
2. `_load_configuration()` - загрузка параметров
3. `run()` - основной цикл
4. `_update_tracker_state(state)` - обновление статуса

### 7.2. Обработка ошибок
- Логирование всех исключений
- Graceful shutdown при ошибках
- Восстановление после временных сбоев БД

### 7.3. Производительность
- Проверка терминации: каждые 100мс
- Основная логика: каждые 60 секунд
- Heartbeat: каждые 60 секунд
- Минимальная нагрузка на БД

## 8. ПРИМЕР ЗАПУСКА

### 8.1. Командная строка
```bash
# Запуск одной конфигурации
python mtf_rsi_ema_strategy_v2.py --config-id 1

# Массовый запуск через скрипт
python run_all_strategies.py
```

### 8.2. Проверка статуса
```sql
-- Статус конкретной стратегии
SELECT * FROM algo.strategyTracker 
WHERE configID = 1

-- Все работающие стратегии
SELECT * FROM algo.strategiesDashboard_v
```

## 9. ОГРАНИЧЕНИЯ И ПРЕДУПРЕЖДЕНИЯ

### 9.1. Ограничения
- Одна стратегия = один процесс Python
- Максимум одна позиция на инструмент
- Торговые часы контролируются стратегией
- Force close в указанное время UTC

### 9.2. Безопасность
- Валидация всех входных параметров
- Проверка существования позиций перед закрытием
- Подтверждение выполнения команд
- Резервное копирование конфигураций

---
*Документ актуален на 2026-01-25*

# ТЕХНИЧЕСКОЕ ЗАДАНИЕ: АРХИТЕКТУРА СИСТЕМЫ ТОРГОВЫХ СТРАТЕГИЙ

## 1. АППАРАТНЫЕ РЕСУРСЫ СИСТЕМЫ

### 1.1. Конфигурация сервера
- **Процессор**: Intel Xeon E5-2620 v4 @ 2.10GHz (8 ядер, 16 потоков)
- **Память**: 64 GB RAM (63.9 GB доступно)
- **Накопители**:
  - SSD 224 GB (система) ×2 (INTEL SSDSC2KB240G7)
  - SSD 477 GB (данные) (SPCC Solid State Disk)
  - HDD 932 GB (архив) (HGST HUS722T1TALA604)
- **Видеокарта**: NVIDIA GeForce GTX 1660 (6 GB)
- **ОС**: 64-bit Windows Server

### 1.2. Ограничения параллелизма стратегий

| Ресурс | Емкость | Рекомендация | Максимум |
|--------|---------|--------------|----------|
| **Процессы Python** | ~100 процессов | **15-20 стратегий** | 30 стратегий |
| **SQL запросы/мин** | ~5000 запросов | **20 стратегий × 2 запроса/мин = 40** | 100 стратегий |
| **Память** | 64 GB | **20 стратегий × 100MB = 2GB** | 50 стратегий |
| **Подключения БД** | 32767 | **20 стратегий × 1 = 20** | 100 стратегий |
| **CPU нагрузка** | 16 потоков | **20% от ядер (3-4 потока)** | 50% ядер |

## 2. ТЕКУЩАЯ АРХИТЕКТУРА

### 2.1. Структура данных
```
algo.strategies (ID, strategy_code, strategy_name, strategy_class_id)
    ↓ FK strategy_class_id
algo.strategy_classes (ID, class_name, class_code)
    ↓ FK strategy_id
algo.ParameterSets (Id, strategy_id, ParameterSetJson)
    ↓ FK parameter_set_id
algo.ConfigurationSets (Id, ParameterSetId, ParameterValuesJson, CreatedAt)
```

### 2.2. Параметры стратегии (JSON)
```json
{
    "ticker": "XAUUSD",
    "ticker_jid": 123,
    "timeframe_signal_id": 1,
    "timeframe_confirmation_id": 3,
    "timeframe_trend_id": 5,
    "open_volume": 0.01,
    "trading_close_utc": "22:00",
    "trading_start_utc": "00:00",
    "broker_id": 2,
    "platform_id": 1,
    "max_position_checks": 10,
    "check_interval_seconds": 10
}
```

## 3. ПАРАЛЛЕЛЬНЫЙ ЗАПУСК СТРАТЕГИЙ

### 3.1. Поддерживаемые сценарии
- ✅ **Одна стратегия → разные configID** (разные инструменты)
- ✅ **Разные стратегии → параллельная работа**
- ⚠️ **Один инструмент → одна стратегия** (ограничение позиций)

### 3.2. Примеры конфигураций
```sql
-- Безопасные параллельные конфигурации
config_id=1 → {"ticker": "XAUUSD", "ticker_jid": 101}
config_id=2 → {"ticker": "XAGUSD", "ticker_jid": 102}  
config_id=3 → {"ticker": "EURUSD", "ticker_jid": 103}
```

### 3.3. Запуск множества стратегий
```python
# run_all_strategies.py - оптимизированный для 20 стратегий
import subprocess
import time
from concurrent.futures import ThreadPoolExecutor

def start_strategy(config_id):
    """Запуск одной стратегии"""
    proc = subprocess.Popen(
        ['python', 'mtf_rsi_ema_strategy_v2.py', '--config-id', str(config_id)],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE
    )
    return proc

# Запуск 15 стратегий с паузой для инициализации БД
config_ids = list(range(1, 16))  # config_id с 1 по 15
processes = []

for i, config_id in enumerate(config_ids):
    print(f"Запуск стратегии {i+1}/15: config_id={config_id}")
    processes.append(start_strategy(config_id))
    
    # Пауза для распределения нагрузки на БД
    if (i + 1) % 5 == 0:
        time.sleep(5)  # 5 секунд после каждых 5 стратегий
    else:
        time.sleep(1)  # 1 секунда между стратегиями
```

## 4. ПРОИЗВОДИТЕЛЬНОСТЬ И ОПТИМИЗАЦИЯ

### 4.1. Профиль нагрузки одной стратегии
- **SQL запросы**: 1 основной запрос × 50мс = 50мс/минуту
- **Память**: ~50-100 MB (Python + pyodbc)
- **CPU**: <1% одного ядра
- **Сеть**: <1 KB/минуту

### 4.2. Расчет для 20 параллельных стратегий
```
Общая нагрузка = 20 × нагрузка_одной
SQL запросы: 20 × 50мс = 1 секунда/минуту (1.6% времени CPU)
Память: 20 × 80MB = 1.6 GB (2.5% от доступной)
Подключения БД: 20 (0.06% от лимита)
```

### 4.3. Рекомендации по мониторингу
```sql
-- Мониторинг нагрузки БД
SELECT 
    COUNT(*) as active_strategies,
    AVG(DATEDIFF(second, modified, GETUTCDATE())) as avg_heartbeat_age_sec
FROM algo.strategyTracker 
WHERE timeClosed IS NULL;

-- Мониторинг позиций
SELECT ticker, COUNT(*) as positions_count
FROM trd.trades_v 
WHERE tradeType = 'POSITION'
GROUP BY ticker;
```

## 5. ТРЕБОВАНИЯ К СТРАТЕГИЯМ

### 5.1. Обязательная оптимизация
1. **Кэширование запросов** - минимизация обращений к БД
2. **Асинхронные проверки** - termination check каждые 100мс
3. **Эффективные запросы** - использование индексов
4. **Очистка ресурсов** - закрытие connection при завершении

### 5.2. Шаблон стратегии
```python
class OptimizedStrategy:
    def __init__(self, config_id):
        self.config_id = config_id
        self._cache = {}  # Кэш для повторяющихся данных
        self._last_query_time = None
        
    def run(self):
        while True:
            # Fast path: проверка терминации (кешированная)
            if self._check_termination_fast():
                break
                
            # Slow path: основная логика (раз в минуту)
            if self._should_run_logic():
                self._execute_trading_logic()
                
            time.sleep(0.1)  # 100ms для быстрого отклика
```

## 6. ОГРАНИЧЕНИЯ И ПРЕДУПРЕЖДЕНИЯ

### 6.1. Аппаратные ограничения
- **Максимум параллельных стратегий**: 20-30 (при текущей реализации)
- **Точка насыщения БД**: ~50 одновременных запросов
- **Лимит памяти**: 2-3GB для Python процессов

### 6.2. Рекомендации по развертыванию
1. **Начинать с 5-10 стратегий**, мониторить нагрузку
2. **Использовать SSD для БД** (477 GB SPCC SSD)
3. **Настроить connection pooling** если нужно >30 стратегий
4. **Регулярно очищать логи** (tms.logsJob_* таблицы)

## 7. ТЕСТИРОВАНИЕ НАГРУЗКИ

### 7.1. Поэтапное тестирование
```bash
# Этап 1: 5 стратегий
for i in {1..5}; do
    python mtf_rsi_ema_strategy_v2.py --config-id $i &
done

# Этап 2: +5 стратегий (всего 10)
sleep 300  # 5 минут работы
for i in {6..10}; do
    python mtf_rsi_ema_strategy_v2.py --config-id $i &
done

# Этап 3: +10 стратегий (всего 20) 
sleep 600  # 10 минут работы
for i in {11..20}; do
    python mtf_rsi_ema_strategy_v2.py --config-id $i &
done
```

### 7.2. Критерии успешного теста
- **CPU нагрузка**: <30% в пике
- **Память**: <4GB использовано
- **Запросы к БД**: <100ms latency
- **Отсутствие deadlock** в таблицах

---
*Конфигурация сервера поддерживает 15-20 параллельных стратегий при текущей архитектуре*  
*Документ актуален на 2026-01-25*